/* automatically generated by rust-bindgen 0.59.2 */

pub type va_list = __builtin_va_list;
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type mode_t = __mode_t;
pub type pid_t = __pid_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
extern "C" {
    pub fn ruby_xmalloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xmalloc2(nelems: size_t, elemsiz: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xcalloc(nelems: size_t, elemsiz: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xrealloc(
        ptr: *mut ::std::os::raw::c_void,
        newsiz: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xrealloc2(
        ptr: *mut ::std::os::raw::c_void,
        newelems: size_t,
        newsiz: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_xfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rb_assert_failure(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    );
}
pub type VALUE = ::std::os::raw::c_ulong;
pub type ID = ::std::os::raw::c_ulong;
extern "C" {
    pub fn rb_class_new(super_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_init_copy(clone: VALUE, orig: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_inheritable(super_: VALUE);
}
extern "C" {
    pub fn rb_define_class_id(id: ID, super_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_define_class_id_under(outer: VALUE, id: ID, super_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_module_new() -> VALUE;
}
extern "C" {
    pub fn rb_refinement_new() -> VALUE;
}
extern "C" {
    pub fn rb_define_module_id(id: ID) -> VALUE;
}
extern "C" {
    pub fn rb_define_module_id_under(outer: VALUE, id: ID) -> VALUE;
}
extern "C" {
    pub fn rb_mod_included_modules(mod_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_include_p(child: VALUE, parent: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_ancestors(mod_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_descendants(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_subclasses(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_public_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_protected_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_private_instance_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_obj_singleton_methods(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        obj: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_define_method_id(
        klass: VALUE,
        mid: ID,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_undef(mod_: VALUE, mid: ID);
}
extern "C" {
    pub fn rb_define_protected_method(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_private_method(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_singleton_method(
        obj: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_singleton_class(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_sourceline() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_sourcefile() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_frame_method_id_and_class(idp: *mut ID, klassp: *mut VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_check_funcall(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_check_funcall_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_eval_cmd_kw(cmd: VALUE, arg: VALUE, kw_splat: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_apply(recv: VALUE, mid: ID, args: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_instance_eval(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_obj_instance_exec(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_module_eval(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_module_exec(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        mod_: VALUE,
    ) -> VALUE;
}
pub type rb_alloc_func_t = ::std::option::Option<unsafe extern "C" fn(klass: VALUE) -> VALUE>;
extern "C" {
    pub fn rb_define_alloc_func(klass: VALUE, func: rb_alloc_func_t);
}
extern "C" {
    pub fn rb_undef_alloc_func(klass: VALUE);
}
extern "C" {
    pub fn rb_get_alloc_func(klass: VALUE) -> rb_alloc_func_t;
}
extern "C" {
    pub fn rb_clear_constant_cache();
}
extern "C" {
    pub fn rb_alias(klass: VALUE, dst: ID, src: ID);
}
extern "C" {
    pub fn rb_attr(
        klass: VALUE,
        name: ID,
        need_reader: ::std::os::raw::c_int,
        need_writer: ::std::os::raw::c_int,
        honour_visibility: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_remove_method(klass: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_remove_method_id(klass: VALUE, mid: ID);
}
extern "C" {
    pub fn rb_method_boundp(
        klass: VALUE,
        id: ID,
        ex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_method_basic_definition_p(klass: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_obj_respond_to(
        obj: VALUE,
        mid: ID,
        private_p: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_respond_to(obj: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_f_notimplement(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        obj: VALUE,
        marker: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_backtrace();
}
extern "C" {
    pub fn rb_make_backtrace() -> VALUE;
}
extern "C" {
    pub fn rb_define_method(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_module_function(
        klass: VALUE,
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_define_global_function(
        mid: *const ::std::os::raw::c_char,
        func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        arity: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_undef_method(klass: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_define_alias(
        klass: VALUE,
        dst: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rb_define_attr(
        klass: VALUE,
        name: *const ::std::os::raw::c_char,
        read: ::std::os::raw::c_int,
        write: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_6 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_7 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_8 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_9 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_10 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_11 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_12 {
    pub x: *mut VALUE,
    pub y: *const VALUE,
}
extern "C" {
    pub fn rb_int2big(i: isize) -> VALUE;
}
extern "C" {
    pub fn rb_int2inum(i: isize) -> VALUE;
}
extern "C" {
    pub fn rb_uint2big(i: usize) -> VALUE;
}
extern "C" {
    pub fn rb_uint2inum(i: usize) -> VALUE;
}
impl ruby_special_consts {
    pub const RUBY_SPECIAL_SHIFT: ruby_special_consts = ruby_special_consts::RUBY_Qnil;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_special_consts {
    RUBY_Qfalse = 0,
    RUBY_Qtrue = 20,
    RUBY_Qnil = 8,
    RUBY_Qundef = 52,
    RUBY_IMMEDIATE_MASK = 7,
    RUBY_FIXNUM_FLAG = 1,
    RUBY_FLONUM_MASK = 3,
    RUBY_FLONUM_FLAG = 2,
    RUBY_SYMBOL_FLAG = 12,
}
extern "C" {
    pub fn rb_out_of_int(num: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_num2long(num: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_num2ulong(num: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_num2int(num: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_fix2int(num: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_num2uint(num: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_fix2uint(num: VALUE) -> ::std::os::raw::c_ulong;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rvalue_flags {
    RVALUE_EMBED_LEN_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
extern "C" {
    pub fn rb_obj_hide(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_reveal(obj: VALUE, klass: VALUE) -> VALUE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rb_warning_category_t {
    RB_WARN_CATEGORY_NONE = 0,
    RB_WARN_CATEGORY_DEPRECATED = 1,
    RB_WARN_CATEGORY_EXPERIMENTAL = 2,
    RB_WARN_CATEGORY_ALL_BITS = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rb_io_wait_readwrite {
    RB_IO_WAIT_READABLE = 0,
    RB_IO_WAIT_WRITABLE = 1,
}
extern "C" {
    pub fn rb_errinfo() -> VALUE;
}
extern "C" {
    pub fn rb_set_errinfo(err: VALUE);
}
extern "C" {
    pub fn rb_raise(exc: VALUE, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_fatal(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_bug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_bug_errno(msg: *const ::std::os::raw::c_char, err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_sys_fail(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_sys_fail_str(msg: VALUE);
}
extern "C" {
    pub fn rb_mod_sys_fail(mod_: VALUE, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_mod_sys_fail_str(mod_: VALUE, msg: VALUE);
}
extern "C" {
    pub fn rb_readwrite_sys_fail(waiting: rb_io_wait_readwrite, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_iter_break();
}
extern "C" {
    pub fn rb_iter_break_value(val: VALUE);
}
extern "C" {
    pub fn rb_exit(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_notimplement();
}
extern "C" {
    pub fn rb_syserr_new(err: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_syserr_new_str(n: ::std::os::raw::c_int, arg: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_syserr_fail(err: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_syserr_fail_str(err: ::std::os::raw::c_int, msg: VALUE);
}
extern "C" {
    pub fn rb_mod_syserr_fail(
        mod_: VALUE,
        err: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rb_mod_syserr_fail_str(mod_: VALUE, err: ::std::os::raw::c_int, msg: VALUE);
}
extern "C" {
    pub fn rb_readwrite_syserr_fail(
        waiting: rb_io_wait_readwrite,
        err: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rb_unexpected_type(self_: VALUE, t: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_ruby_verbose_ptr() -> *mut VALUE;
}
extern "C" {
    pub fn rb_ruby_debug_ptr() -> *mut VALUE;
}
extern "C" {
    pub fn rb_warning(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_category_warning(cat: rb_warning_category_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_compile_warning(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn rb_sys_warning(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_warn(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_category_warn(cat: rb_warning_category_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_compile_warn(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn rb_category_compile_warn(
        cat: rb_warning_category_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_value_type {
    RUBY_T_NONE = 0,
    RUBY_T_OBJECT = 1,
    RUBY_T_CLASS = 2,
    RUBY_T_MODULE = 3,
    RUBY_T_FLOAT = 4,
    RUBY_T_STRING = 5,
    RUBY_T_REGEXP = 6,
    RUBY_T_ARRAY = 7,
    RUBY_T_HASH = 8,
    RUBY_T_STRUCT = 9,
    RUBY_T_BIGNUM = 10,
    RUBY_T_FILE = 11,
    RUBY_T_DATA = 12,
    RUBY_T_MATCH = 13,
    RUBY_T_COMPLEX = 14,
    RUBY_T_RATIONAL = 15,
    RUBY_T_NIL = 17,
    RUBY_T_TRUE = 18,
    RUBY_T_FALSE = 19,
    RUBY_T_SYMBOL = 20,
    RUBY_T_FIXNUM = 21,
    RUBY_T_UNDEF = 22,
    RUBY_T_IMEMO = 26,
    RUBY_T_NODE = 27,
    RUBY_T_ICLASS = 28,
    RUBY_T_ZOMBIE = 29,
    RUBY_T_MOVED = 30,
    RUBY_T_MASK = 31,
}
extern "C" {
    pub fn rb_check_type(obj: VALUE, t: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_fl_ushift {
    RUBY_FL_USHIFT = 12,
}
impl ruby_fl_type {
    pub const RUBY_FL_PROMOTED0: ruby_fl_type = ruby_fl_type::RUBY_FL_WB_PROTECTED;
}
impl ruby_fl_type {
    pub const RUBY_FL_SHAREABLE: ruby_fl_type = ruby_fl_type::RUBY_FL_TAINT;
}
impl ruby_fl_type {
    pub const RUBY_FL_UNTRUSTED: ruby_fl_type = ruby_fl_type::RUBY_FL_TAINT;
}
impl ruby_fl_type {
    pub const RUBY_ELTS_SHARED: ruby_fl_type = ruby_fl_type::RUBY_FL_USER2;
}
impl ruby_fl_type {
    pub const RUBY_FL_SINGLETON: ruby_fl_type = ruby_fl_type::RUBY_FL_USER0;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_fl_type {
    RUBY_FL_WB_PROTECTED = 32,
    RUBY_FL_PROMOTED1 = 64,
    RUBY_FL_PROMOTED = 96,
    RUBY_FL_FINALIZE = 128,
    RUBY_FL_TAINT = 256,
    RUBY_FL_SEEN_OBJ_ID = 512,
    RUBY_FL_EXIVAR = 1024,
    RUBY_FL_FREEZE = 2048,
    RUBY_FL_USER0 = 4096,
    RUBY_FL_USER1 = 8192,
    RUBY_FL_USER2 = 16384,
    RUBY_FL_USER3 = 32768,
    RUBY_FL_USER4 = 65536,
    RUBY_FL_USER5 = 131072,
    RUBY_FL_USER6 = 262144,
    RUBY_FL_USER7 = 524288,
    RUBY_FL_USER8 = 1048576,
    RUBY_FL_USER9 = 2097152,
    RUBY_FL_USER10 = 4194304,
    RUBY_FL_USER11 = 8388608,
    RUBY_FL_USER12 = 16777216,
    RUBY_FL_USER13 = 33554432,
    RUBY_FL_USER14 = 67108864,
    RUBY_FL_USER15 = 134217728,
    RUBY_FL_USER16 = 268435456,
    RUBY_FL_USER17 = 536870912,
    RUBY_FL_USER18 = 1073741824,
    RUBY_FL_USER19 = -2147483648,
}
extern "C" {
    pub fn rb_obj_infect(victim: VALUE, carrier: VALUE);
}
extern "C" {
    pub fn rb_freeze_singleton_class(klass: VALUE);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rstring_flags {
    RSTRING_NOEMBED = 8192,
    RSTRING_EMBED_LEN_MASK = 507904,
    RSTRING_FSTR = 536870912,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rstring_consts {
    RSTRING_EMBED_LEN_SHIFT = 14,
    RSTRING_EMBED_LEN_MAX = 23,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString {
    pub basic: RBasic,
    pub as_: RString__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1 {
    pub heap: RString__bindgen_ty_1__bindgen_ty_1,
    pub embed: RString__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *mut ::std::os::raw::c_char,
    pub aux: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared: VALUE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RString__bindgen_ty_1__bindgen_ty_2 {
    pub ary: [::std::os::raw::c_char; 24usize],
}
extern "C" {
    pub fn rb_str_to_str(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_string_value(ptr: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_string_value_ptr(ptr: *mut VALUE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_string_value_cstr(ptr: *mut VALUE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_str_export(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_export_locale(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_safe_str(arg1: VALUE);
}
extern "C" {
    pub fn rb_debug_rstring_null_ptr(func: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_num2dbl(num: VALUE) -> f64;
}
extern "C" {
    pub fn rb_float_value(num: VALUE) -> f64;
}
extern "C" {
    pub fn rb_float_new(d: f64) -> VALUE;
}
extern "C" {
    pub fn rb_float_new_in_heap(d: f64) -> VALUE;
}
extern "C" {
    pub fn rb_ll2inum(num: ::std::os::raw::c_longlong) -> VALUE;
}
extern "C" {
    pub fn rb_ull2inum(num: ::std::os::raw::c_ulonglong) -> VALUE;
}
extern "C" {
    pub fn rb_num2ll(num: VALUE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn rb_num2ull(num: VALUE) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rb_num2short(num: VALUE) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn rb_num2ushort(num: VALUE) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn rb_fix2short(num: VALUE) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn rb_fix2ushort(num: VALUE) -> ::std::os::raw::c_ushort;
}
pub type st_data_t = ::std::os::raw::c_ulong;
pub type st_index_t = st_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_hash_type {
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int,
    >,
    pub hash: ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_index_t>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table {
    pub entry_power: ::std::os::raw::c_uchar,
    pub bin_power: ::std::os::raw::c_uchar,
    pub size_ind: ::std::os::raw::c_uchar,
    pub rebuilds_num: ::std::os::raw::c_uint,
    pub type_: *const st_hash_type,
    pub num_entries: st_index_t,
    pub bins: *mut st_index_t,
    pub entries_start: st_index_t,
    pub entries_bound: st_index_t,
    pub entries: *mut st_table_entry,
}
extern "C" {
    pub fn rb_st_init_table(arg1: *const st_hash_type) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_table_with_size(arg1: *const st_hash_type, arg2: st_index_t)
        -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_numtable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_numtable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strtable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strtable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strcasetable() -> *mut st_table;
}
extern "C" {
    pub fn rb_st_init_strcasetable_with_size(arg1: st_index_t) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_delete(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_delete_safe(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
        arg4: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_shift(
        arg1: *mut st_table,
        arg2: *mut st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_insert(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_insert2(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: st_data_t,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_data_t>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_lookup(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_get_key(
        arg1: *mut st_table,
        arg2: st_data_t,
        arg3: *mut st_data_t,
    ) -> ::std::os::raw::c_int;
}
pub type st_update_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        key: *mut st_data_t,
        value: *mut st_data_t,
        arg: st_data_t,
        existing: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_st_update(
        table: *mut st_table,
        key: st_data_t,
        func: st_update_callback_func,
        arg: st_data_t,
    ) -> ::std::os::raw::c_int;
}
pub type st_foreach_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: st_data_t,
        arg2: st_data_t,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int,
>;
pub type st_foreach_check_callback_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: st_data_t,
        arg2: st_data_t,
        arg3: st_data_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_st_foreach_with_replace(
        tab: *mut st_table,
        func: st_foreach_check_callback_func,
        replace: st_update_callback_func,
        arg: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_foreach(
        arg1: *mut st_table,
        arg2: st_foreach_callback_func,
        arg3: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_foreach_check(
        arg1: *mut st_table,
        arg2: st_foreach_check_callback_func,
        arg3: st_data_t,
        arg4: st_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_keys(table: *mut st_table, keys: *mut st_data_t, size: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_keys_check(
        table: *mut st_table,
        keys: *mut st_data_t,
        size: st_index_t,
        never: st_data_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_values(
        table: *mut st_table,
        values: *mut st_data_t,
        size: st_index_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_values_check(
        table: *mut st_table,
        values: *mut st_data_t,
        size: st_index_t,
        never: st_data_t,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_st_add_direct(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t);
}
extern "C" {
    pub fn rb_st_free_table(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_st_cleanup_safe(arg1: *mut st_table, arg2: st_data_t);
}
extern "C" {
    pub fn rb_st_clear(arg1: *mut st_table);
}
extern "C" {
    pub fn rb_st_copy(arg1: *mut st_table) -> *mut st_table;
}
extern "C" {
    pub fn rb_st_numcmp(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_numhash(arg1: st_data_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_locale_insensitive_strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_locale_insensitive_strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_st_memsize(arg1: *const st_table) -> size_t;
}
extern "C" {
    pub fn rb_st_hash(ptr: *const ::std::os::raw::c_void, len: size_t, h: st_index_t)
        -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_uint32(h: st_index_t, i: u32) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_uint(h: st_index_t, i: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_end(h: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_st_hash_start(h: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_bulk_insert_into_st_table(
        arg1: ::std::os::raw::c_long,
        arg2: *const VALUE,
        arg3: VALUE,
    );
}
extern "C" {
    pub fn rb_gc_writebarrier(old: VALUE, young: VALUE);
}
extern "C" {
    pub fn rb_gc_writebarrier_unprotect(obj: VALUE);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rarray_flags {
    RARRAY_EMBED_FLAG = 8192,
    RARRAY_EMBED_LEN_MASK = 98304,
    RARRAY_TRANSIENT_FLAG = 33554432,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rarray_consts {
    RARRAY_EMBED_LEN_SHIFT = 15,
    RARRAY_EMBED_LEN_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray {
    pub basic: RBasic,
    pub as_: RArray__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1 {
    pub heap: RArray__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub aux: RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ptr: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared_root: VALUE,
}
extern "C" {
    pub fn rb_ary_ptr_use_start(ary: VALUE) -> *mut VALUE;
}
extern "C" {
    pub fn rb_ary_ptr_use_end(a: VALUE);
}
extern "C" {
    pub fn rb_ary_detransient(a: VALUE);
}
extern "C" {
    pub fn rb_big_sign(num: VALUE) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_rmodule_flags {
    RMODULE_IS_OVERLAID = 16384,
    RMODULE_IS_REFINEMENT = 32768,
    RMODULE_INCLUDED_INTO_REFINEMENT = 65536,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RClass {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rb_class_get_superclass(klass: VALUE) -> VALUE;
}
pub type RUBY_DATA_FUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RData {
    pub basic: RBasic,
    pub dmark: RUBY_DATA_FUNC,
    pub dfree: RUBY_DATA_FUNC,
    pub data: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub fn rb_data_object_wrap(
        klass: VALUE,
        datap: *mut ::std::os::raw::c_void,
        dmark: RUBY_DATA_FUNC,
        dfree: RUBY_DATA_FUNC,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_data_object_zalloc(
        klass: VALUE,
        size: size_t,
        dmark: RUBY_DATA_FUNC,
        dfree: RUBY_DATA_FUNC,
    ) -> VALUE;
}
extern "C" {
    pub static mut rb_cObject: VALUE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_io_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RFile {
    pub basic: RBasic,
    pub fptr: *mut rb_io_t,
}
extern "C" {
    pub fn ruby_sysinit(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ruby_init();
}
extern "C" {
    pub fn ruby_options(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_executable_node(
        n: *mut ::std::os::raw::c_void,
        status: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_run_node(n: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_show_version();
}
extern "C" {
    pub fn ruby_show_copyright();
}
extern "C" {
    pub fn ruby_init_stack(addr: *mut VALUE);
}
extern "C" {
    pub fn ruby_setup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_cleanup(ex: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_finalize();
}
extern "C" {
    pub fn ruby_stop(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ruby_stack_check() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_stack_length(topnotch: *mut *mut VALUE) -> size_t;
}
extern "C" {
    pub fn ruby_exec_node(n: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_script(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ruby_set_script_name(name: VALUE);
}
extern "C" {
    pub fn ruby_prog_init();
}
extern "C" {
    pub fn ruby_set_argv(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn ruby_process_options(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_init_loadpath();
}
extern "C" {
    pub fn ruby_incpush(path: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ruby_sig_finalize();
}
extern "C" {
    pub fn rb_disable_super();
}
extern "C" {
    pub fn rb_enable_super();
}
extern "C" {
    pub fn rb_hash_iter_lev();
}
extern "C" {
    pub fn rb_hash_ifnone();
}
extern "C" {
    pub fn rb_str_associate();
}
extern "C" {
    pub fn rb_str_associated();
}
extern "C" {
    pub fn rb_autoload();
}
extern "C" {
    pub fn rb_frozen_class_p();
}
extern "C" {
    pub fn rb_exec_end_proc();
}
extern "C" {
    pub fn rb_compile_error();
}
extern "C" {
    pub fn rb_compile_error_with_enc();
}
extern "C" {
    pub fn rb_compile_error_append();
}
extern "C" {
    pub fn rb_gc_call_finalizer_at_exit();
}
extern "C" {
    pub fn rb_trap_exit();
}
extern "C" {
    pub fn rb_struct_ptr();
}
extern "C" {
    pub fn rb_clear_trace_func();
}
extern "C" {
    pub fn rb_generic_ivar_table();
}
extern "C" {
    pub fn rb_mod_const_missing(arg1: VALUE, arg2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_size_num(hash: VALUE) -> size_t;
}
extern "C" {
    pub fn rb_hash_tbl(
        hash: VALUE,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut st_table;
}
extern "C" {
    pub fn rb_hash_set_ifnone(hash: VALUE, ifnone: VALUE) -> VALUE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_robject_flags {
    ROBJECT_EMBED = 8192,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_robject_consts {
    ROBJECT_EMBED_LEN_MAX = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RObject {
    pub basic: RBasic,
    pub as_: RObject__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RObject__bindgen_ty_1 {
    pub heap: RObject__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RObject__bindgen_ty_1__bindgen_ty_1 {
    pub numiv: u32,
    pub ivptr: *mut VALUE,
    pub iv_index_tbl: *mut st_table,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RRegexp {
    pub basic: RBasic,
    pub ptr: *mut re_pattern_buffer,
    pub src: VALUE,
    pub usecnt: ::std::os::raw::c_ulong,
}
extern "C" {
    pub fn rb_struct_size(st: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_aref(st: VALUE, k: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_aset(st: VALUE, k: VALUE, v: VALUE) -> VALUE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rbimpl_typeddata_flags {
    RUBY_TYPED_FREE_IMMEDIATELY = 1,
    RUBY_TYPED_FROZEN_SHAREABLE = 256,
    RUBY_TYPED_WB_PROTECTED = 32,
    RUBY_TYPED_PROMOTED1 = 64,
}
pub type rb_data_type_t = rb_data_type_struct;
#[repr(C)]
#[derive(Debug)]
pub struct rb_data_type_struct {
    pub wrap_struct_name: *const ::std::os::raw::c_char,
    pub function: rb_data_type_struct__bindgen_ty_1,
    pub parent: *const rb_data_type_t,
    pub data: *mut ::std::os::raw::c_void,
    pub flags: VALUE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_data_type_struct__bindgen_ty_1 {
    pub dmark: RUBY_DATA_FUNC,
    pub dfree: RUBY_DATA_FUNC,
    pub dsize:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> size_t>,
    pub dcompact: RUBY_DATA_FUNC,
    pub reserved: [*mut ::std::os::raw::c_void; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTypedData {
    pub basic: RBasic,
    pub type_: *const rb_data_type_t,
    pub typed_flag: VALUE,
    pub data: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub fn rb_data_typed_object_wrap(
        klass: VALUE,
        datap: *mut ::std::os::raw::c_void,
        type_: *const rb_data_type_t,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_data_typed_object_zalloc(
        klass: VALUE,
        size: size_t,
        type_: *const rb_data_type_t,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_typeddata_inherited_p(
        child: *const rb_data_type_t,
        parent: *const rb_data_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_typeddata_is_kind_of(
        obj: VALUE,
        data_type: *const rb_data_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_check_typeddata(
        obj: VALUE,
        data_type: *const rb_data_type_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ruby_strtoul(
        str_: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_eval_string(str_: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_eval_string_protect(
        str_: *const ::std::os::raw::c_char,
        state: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_eval_string_wrap(
        str_: *const ::std::os::raw::c_char,
        state: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall(recv: VALUE, mid: ID, n: ::std::os::raw::c_int, ...) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv_public(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcallv_public_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_passing_block(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_passing_block_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_with_block(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        procval: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_funcall_with_block_kw(
        recv: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        procval: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_call_super(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_call_super_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_current_receiver() -> VALUE;
}
extern "C" {
    pub fn rb_get_kwargs(
        keyword_hash: VALUE,
        table: *const ID,
        required: ::std::os::raw::c_int,
        optional: ::std::os::raw::c_int,
        values: *mut VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_extract_keywords(orighash: *mut VALUE) -> VALUE;
}
pub type rb_event_flag_t = u32;
pub type rb_event_hook_func_t = ::std::option::Option<
    unsafe extern "C" fn(evflag: rb_event_flag_t, data: VALUE, self_: VALUE, mid: ID, klass: VALUE),
>;
extern "C" {
    pub fn rb_add_event_hook(func: rb_event_hook_func_t, events: rb_event_flag_t, data: VALUE);
}
extern "C" {
    pub fn rb_remove_event_hook(func: rb_event_hook_func_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_gc_register_address(valptr: *mut VALUE);
}
extern "C" {
    pub fn rb_global_variable(arg1: *mut VALUE);
}
extern "C" {
    pub fn rb_gc_unregister_address(valptr: *mut VALUE);
}
extern "C" {
    pub fn rb_gc_register_mark_object(object: VALUE);
}
pub type ruby_glob_func = ::std::option::Option<
    unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        arg: VALUE,
        enc: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rb_glob(
        pattern: *const ::std::os::raw::c_char,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                path: *const ::std::os::raw::c_char,
                arg: VALUE,
                enc: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: VALUE,
    );
}
extern "C" {
    pub fn ruby_glob(
        pattern: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        func: ruby_glob_func,
        arg: VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_brace_glob(
        pattern: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        func: ruby_glob_func,
        arg: VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rb_mKernel: VALUE;
}
extern "C" {
    pub static mut rb_mComparable: VALUE;
}
extern "C" {
    pub static mut rb_mEnumerable: VALUE;
}
extern "C" {
    pub static mut rb_mErrno: VALUE;
}
extern "C" {
    pub static mut rb_mFileTest: VALUE;
}
extern "C" {
    pub static mut rb_mGC: VALUE;
}
extern "C" {
    pub static mut rb_mMath: VALUE;
}
extern "C" {
    pub static mut rb_mProcess: VALUE;
}
extern "C" {
    pub static mut rb_mWaitReadable: VALUE;
}
extern "C" {
    pub static mut rb_mWaitWritable: VALUE;
}
extern "C" {
    pub static mut rb_cBasicObject: VALUE;
}
extern "C" {
    pub static mut rb_cArray: VALUE;
}
extern "C" {
    pub static mut rb_cBinding: VALUE;
}
extern "C" {
    pub static mut rb_cClass: VALUE;
}
extern "C" {
    pub static mut rb_cDir: VALUE;
}
extern "C" {
    pub static mut rb_cEncoding: VALUE;
}
extern "C" {
    pub static mut rb_cEnumerator: VALUE;
}
extern "C" {
    pub static mut rb_cFalseClass: VALUE;
}
extern "C" {
    pub static mut rb_cFile: VALUE;
}
extern "C" {
    pub static mut rb_cComplex: VALUE;
}
extern "C" {
    pub static mut rb_cFloat: VALUE;
}
extern "C" {
    pub static mut rb_cHash: VALUE;
}
extern "C" {
    pub static mut rb_cIO: VALUE;
}
extern "C" {
    pub static mut rb_cInteger: VALUE;
}
extern "C" {
    pub static mut rb_cMatch: VALUE;
}
extern "C" {
    pub static mut rb_cMethod: VALUE;
}
extern "C" {
    pub static mut rb_cModule: VALUE;
}
extern "C" {
    pub static mut rb_cRefinement: VALUE;
}
extern "C" {
    pub static mut rb_cNameErrorMesg: VALUE;
}
extern "C" {
    pub static mut rb_cNilClass: VALUE;
}
extern "C" {
    pub static mut rb_cNumeric: VALUE;
}
extern "C" {
    pub static mut rb_cProc: VALUE;
}
extern "C" {
    pub static mut rb_cRandom: VALUE;
}
extern "C" {
    pub static mut rb_cRange: VALUE;
}
extern "C" {
    pub static mut rb_cRational: VALUE;
}
extern "C" {
    pub static mut rb_cRegexp: VALUE;
}
extern "C" {
    pub static mut rb_cStat: VALUE;
}
extern "C" {
    pub static mut rb_cString: VALUE;
}
extern "C" {
    pub static mut rb_cStruct: VALUE;
}
extern "C" {
    pub static mut rb_cSymbol: VALUE;
}
extern "C" {
    pub static mut rb_cThread: VALUE;
}
extern "C" {
    pub static mut rb_cTime: VALUE;
}
extern "C" {
    pub static mut rb_cTrueClass: VALUE;
}
extern "C" {
    pub static mut rb_cUnboundMethod: VALUE;
}
extern "C" {
    pub static mut rb_eException: VALUE;
}
extern "C" {
    pub static mut rb_eStandardError: VALUE;
}
extern "C" {
    pub static mut rb_eSystemExit: VALUE;
}
extern "C" {
    pub static mut rb_eInterrupt: VALUE;
}
extern "C" {
    pub static mut rb_eSignal: VALUE;
}
extern "C" {
    pub static mut rb_eFatal: VALUE;
}
extern "C" {
    pub static mut rb_eArgError: VALUE;
}
extern "C" {
    pub static mut rb_eEOFError: VALUE;
}
extern "C" {
    pub static mut rb_eIndexError: VALUE;
}
extern "C" {
    pub static mut rb_eStopIteration: VALUE;
}
extern "C" {
    pub static mut rb_eKeyError: VALUE;
}
extern "C" {
    pub static mut rb_eRangeError: VALUE;
}
extern "C" {
    pub static mut rb_eIOError: VALUE;
}
extern "C" {
    pub static mut rb_eRuntimeError: VALUE;
}
extern "C" {
    pub static mut rb_eFrozenError: VALUE;
}
extern "C" {
    pub static mut rb_eSecurityError: VALUE;
}
extern "C" {
    pub static mut rb_eSystemCallError: VALUE;
}
extern "C" {
    pub static mut rb_eThreadError: VALUE;
}
extern "C" {
    pub static mut rb_eTypeError: VALUE;
}
extern "C" {
    pub static mut rb_eZeroDivError: VALUE;
}
extern "C" {
    pub static mut rb_eNotImpError: VALUE;
}
extern "C" {
    pub static mut rb_eNoMemError: VALUE;
}
extern "C" {
    pub static mut rb_eNoMethodError: VALUE;
}
extern "C" {
    pub static mut rb_eFloatDomainError: VALUE;
}
extern "C" {
    pub static mut rb_eLocalJumpError: VALUE;
}
extern "C" {
    pub static mut rb_eSysStackError: VALUE;
}
extern "C" {
    pub static mut rb_eRegexpError: VALUE;
}
extern "C" {
    pub static mut rb_eEncodingError: VALUE;
}
extern "C" {
    pub static mut rb_eEncCompatError: VALUE;
}
extern "C" {
    pub static mut rb_eNoMatchingPatternError: VALUE;
}
extern "C" {
    pub static mut rb_eNoMatchingPatternKeyError: VALUE;
}
extern "C" {
    pub static mut rb_eScriptError: VALUE;
}
extern "C" {
    pub static mut rb_eNameError: VALUE;
}
extern "C" {
    pub static mut rb_eSyntaxError: VALUE;
}
extern "C" {
    pub static mut rb_eLoadError: VALUE;
}
extern "C" {
    pub static mut rb_eMathDomainError: VALUE;
}
extern "C" {
    pub static mut rb_stdin: VALUE;
}
extern "C" {
    pub static mut rb_stdout: VALUE;
}
extern "C" {
    pub static mut rb_stderr: VALUE;
}
pub type rb_block_call_func = ::std::option::Option<
    unsafe extern "C" fn(
        yielded_arg: VALUE,
        callback_arg: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        blockarg: VALUE,
    ) -> VALUE,
>;
pub type rb_block_call_func_t = rb_block_call_func;
extern "C" {
    pub fn rb_each(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield_values(n: ::std::os::raw::c_int, ...) -> VALUE;
}
extern "C" {
    pub fn rb_yield_values2(n: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield_values_kw(
        n: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_yield_splat(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_yield_splat_kw(ary: VALUE, kw_splat: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_yield_block(
        yielded_arg: VALUE,
        callback_arg: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        blockarg: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_keyword_given_p() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_block_given_p() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_need_block();
}
extern "C" {
    pub fn rb_iterate(
        func1: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        proc_: rb_block_call_func_t,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_block_call(
        obj: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: rb_block_call_func_t,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_block_call_kw(
        obj: VALUE,
        mid: ID,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: rb_block_call_func_t,
        data2: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_rescue(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        r_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_rescue2(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        r_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        data2: VALUE,
        ...
    ) -> VALUE;
}
extern "C" {
    pub fn rb_vrescue2(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        r_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
        data2: VALUE,
        ap: *mut __va_list_tag,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_ensure(
        b_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data1: VALUE,
        e_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        data2: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_catch(
        tag: *const ::std::os::raw::c_char,
        func: rb_block_call_func_t,
        data: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_catch_obj(tag: VALUE, func: rb_block_call_func_t, data: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_throw(tag: *const ::std::os::raw::c_char, val: VALUE);
}
extern "C" {
    pub fn rb_throw_obj(tag: VALUE, val: VALUE);
}
extern "C" {
    pub fn rb_alloc_tmp_buffer(
        store: *mut VALUE,
        len: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_alloc_tmp_buffer_with_count(
        store: *mut VALUE,
        len: size_t,
        count: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_free_tmp_buffer(store: *mut VALUE);
}
extern "C" {
    pub fn ruby_malloc_size_overflow(x: size_t, y: size_t);
}
extern "C" {
    pub fn rb_define_class(name: *const ::std::os::raw::c_char, super_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_define_module(name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_define_class_under(
        outer: VALUE,
        name: *const ::std::os::raw::c_char,
        super_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_define_module_under(outer: VALUE, name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_include_module(klass: VALUE, module: VALUE);
}
extern "C" {
    pub fn rb_extend_object(obj: VALUE, mod_: VALUE);
}
extern "C" {
    pub fn rb_prepend_module(klass: VALUE, module: VALUE);
}
extern "C" {
    pub fn rb_newobj() -> VALUE;
}
extern "C" {
    pub fn rb_newobj_of(klass: VALUE, flags: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_setup(obj: VALUE, klass: VALUE, type_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_class(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_singleton_class_clone(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_singleton_class_attached(klass: VALUE, obj: VALUE);
}
extern "C" {
    pub fn rb_copy_generic_ivar(clone: VALUE, obj: VALUE);
}
extern "C" {
    pub fn rb_mem_clear(buf: *mut VALUE, len: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_assoc_new(car: VALUE, cdr: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_array_type(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_new() -> VALUE;
}
extern "C" {
    pub fn rb_ary_new_capa(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_new_from_args(n: ::std::os::raw::c_long, ...) -> VALUE;
}
extern "C" {
    pub fn rb_ary_new_from_values(n: ::std::os::raw::c_long, elts: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_tmp_new(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_free(ary: VALUE);
}
extern "C" {
    pub fn rb_ary_modify(ary: VALUE);
}
extern "C" {
    pub fn rb_ary_freeze(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_shared_with_p(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_aref(argc: ::std::os::raw::c_int, argv: *const VALUE, ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_subseq(
        ary: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_ary_store(ary: VALUE, key: ::std::os::raw::c_long, val: VALUE);
}
extern "C" {
    pub fn rb_ary_dup(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_resurrect(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_to_ary(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_to_s(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_cat(ary: VALUE, train: *const VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_push(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_pop(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_shift(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_unshift(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_entry(ary: VALUE, off: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_each(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_join(ary: VALUE, sep: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_reverse(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_rotate(ary: VALUE, rot: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_sort(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_sort_bang(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_delete(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_delete_at(ary: VALUE, pos: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_ary_clear(ary: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_plus(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_concat(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_assoc(alist: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_rassoc(alist: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_includes(ary: VALUE, elem: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_cmp(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ary_replace(copy: VALUE, orig: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_get_values_at(
        obj: VALUE,
        olen: ::std::os::raw::c_long,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        func: ::std::option::Option<
            unsafe extern "C" fn(obj: VALUE, oidx: ::std::os::raw::c_long) -> VALUE,
        >,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_ary_resize(ary: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_exc_new(
        etype: VALUE,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exc_new_cstr(etype: VALUE, str_: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_exc_new_str(etype: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_loaderror(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_loaderror_with_path(path: VALUE, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_name_error(name: ID, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_name_error_str(name: VALUE, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_frozen_error_raise(recv: VALUE, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_invalid_str(
        str_: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn rb_error_frozen(what: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_error_frozen_object(what: VALUE);
}
extern "C" {
    pub fn rb_error_untrusted(arg1: VALUE);
}
extern "C" {
    pub fn rb_check_frozen(obj: VALUE);
}
extern "C" {
    pub fn rb_check_trusted(arg1: VALUE);
}
extern "C" {
    pub fn rb_check_copyable(obj: VALUE, orig: VALUE);
}
extern "C" {
    pub fn rb_error_arity(
        argc: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_st_foreach_safe(st: *mut st_table, func: st_foreach_callback_func, arg: st_data_t);
}
extern "C" {
    pub fn rb_check_hash_type(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_foreach(
        hash: VALUE,
        func: ::std::option::Option<
            unsafe extern "C" fn(key: VALUE, val: VALUE, arg: VALUE) -> ::std::os::raw::c_int,
        >,
        arg: VALUE,
    );
}
extern "C" {
    pub fn rb_hash(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_new() -> VALUE;
}
extern "C" {
    pub fn rb_hash_dup(hash: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_freeze(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_aref(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_lookup(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_lookup2(hash: VALUE, key: VALUE, def: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_fetch(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_aset(hash: VALUE, key: VALUE, val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_clear(hash: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_delete_if(hash: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_delete(hash: VALUE, key: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_hash_bulk_insert(argc: ::std::os::raw::c_long, argv: *const VALUE, hash: VALUE);
}
pub type rb_hash_update_func = ::std::option::Option<
    unsafe extern "C" fn(newkey: VALUE, oldkey: VALUE, value: VALUE) -> VALUE,
>;
extern "C" {
    pub fn rb_hash_update_by(hash1: VALUE, hash2: VALUE, func: rb_hash_update_func) -> VALUE;
}
extern "C" {
    pub fn rb_path_check(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_env_path_tainted() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_env_clear() -> VALUE;
}
extern "C" {
    pub fn rb_hash_size(hash: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_block_proc() -> VALUE;
}
extern "C" {
    pub fn rb_block_lambda() -> VALUE;
}
extern "C" {
    pub fn rb_proc_new(func: rb_block_call_func_t, callback_arg: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_proc(recv: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call(recv: VALUE, args: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call_kw(recv: VALUE, args: VALUE, kw_splat: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call_with_block(
        recv: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_proc_call_with_block_kw(
        recv: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        proc_: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_proc_arity(recv: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_proc_lambda_p(recv: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_binding_new() -> VALUE;
}
extern "C" {
    pub fn rb_obj_method(recv: VALUE, mid: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_method(recv: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_method_call(argc: ::std::os::raw::c_int, argv: *const VALUE, recv: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_method_call_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_method_call_with_block(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
        proc_: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_method_call_with_block_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
        proc_: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_method_arity(mod_: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_obj_method_arity(obj: VALUE, mid: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_protect(
        func: ::std::option::Option<unsafe extern "C" fn(args: VALUE) -> VALUE>,
        args: VALUE,
        state: *mut ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_scan_args(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_scan_args_kw(
        kw_splat: ::std::os::raw::c_int,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_scan_args_bad_format(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_scan_args_length_mismatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_sym2id(obj: VALUE) -> ID;
}
extern "C" {
    pub fn rb_id2sym(id: ID) -> VALUE;
}
extern "C" {
    pub fn rb_intern(name: *const ::std::os::raw::c_char) -> ID;
}
extern "C" {
    pub fn rb_intern2(name: *const ::std::os::raw::c_char, len: ::std::os::raw::c_long) -> ID;
}
extern "C" {
    pub fn rb_intern_str(str_: VALUE) -> ID;
}
extern "C" {
    pub fn rb_id2name(id: ID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_check_id(namep: *mut VALUE) -> ID;
}
extern "C" {
    pub fn rb_to_id(str_: VALUE) -> ID;
}
extern "C" {
    pub fn rb_id2str(id: ID) -> VALUE;
}
extern "C" {
    pub fn rb_sym2str(id: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_to_symbol(name: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_symbol(namep: *mut VALUE) -> VALUE;
}
pub type rb_gvar_getter_t =
    ::std::option::Option<unsafe extern "C" fn(id: ID, data: *mut VALUE) -> VALUE>;
pub type rb_gvar_setter_t =
    ::std::option::Option<unsafe extern "C" fn(val: VALUE, id: ID, data: *mut VALUE)>;
pub type rb_gvar_marker_t = ::std::option::Option<unsafe extern "C" fn(var: *mut VALUE)>;
extern "C" {
    pub fn rb_gvar_undef_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gvar_undef_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_undef_marker(var: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_val_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gvar_val_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_val_marker(var: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_var_getter(id: ID, data: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gvar_var_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_var_marker(var: *mut VALUE);
}
extern "C" {
    pub fn rb_gvar_readonly_setter(arg1: VALUE, arg2: ID, arg3: *mut VALUE);
}
extern "C" {
    pub fn rb_define_variable(name: *const ::std::os::raw::c_char, var: *mut VALUE);
}
extern "C" {
    pub fn rb_define_virtual_variable(
        name: *const ::std::os::raw::c_char,
        getter: rb_gvar_getter_t,
        setter: rb_gvar_setter_t,
    );
}
extern "C" {
    pub fn rb_define_hooked_variable(
        name: *const ::std::os::raw::c_char,
        var: *mut VALUE,
        getter: rb_gvar_getter_t,
        setter: rb_gvar_setter_t,
    );
}
extern "C" {
    pub fn rb_define_readonly_variable(name: *const ::std::os::raw::c_char, var: *const VALUE);
}
extern "C" {
    pub fn rb_define_const(klass: VALUE, name: *const ::std::os::raw::c_char, val: VALUE);
}
extern "C" {
    pub fn rb_define_global_const(name: *const ::std::os::raw::c_char, val: VALUE);
}
extern "C" {
    pub fn rb_deprecate_constant(mod_: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_gv_set(name: *const ::std::os::raw::c_char, val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gv_get(name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_iv_get(obj: VALUE, name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_iv_set(obj: VALUE, name: *const ::std::os::raw::c_char, val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_get_path(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_get_path_no_checksafe(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class2name(klass: VALUE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_obj_classname(obj: VALUE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_p(obj: VALUE);
}
extern "C" {
    pub fn rb_equal(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_require(feature: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_big_new(len: size_t, sign: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_bigzero_p(x: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_big_clone(num: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_2comp(num: VALUE);
}
extern "C" {
    pub fn rb_big_norm(x: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_resize(big: VALUE, len: size_t);
}
extern "C" {
    pub fn rb_cstr_to_inum(
        str_: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
        badcheck: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_to_inum(
        str_: VALUE,
        base: ::std::os::raw::c_int,
        badcheck: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_cstr2inum(str_: *const ::std::os::raw::c_char, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_str2inum(str_: VALUE, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_big2str(x: VALUE, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_big2long(x: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_big2ulong(x: VALUE) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_big2ll(arg1: VALUE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn rb_big2ull(arg1: VALUE) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rb_big_pack(
        val: VALUE,
        buf: *mut ::std::os::raw::c_ulong,
        num_longs: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn rb_big_unpack(
        buf: *mut ::std::os::raw::c_ulong,
        num_longs: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_uv_to_utf8(
        buf: *mut ::std::os::raw::c_char,
        uv: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_dbl2big(d: f64) -> VALUE;
}
extern "C" {
    pub fn rb_big2dbl(x: VALUE) -> f64;
}
extern "C" {
    pub fn rb_big_cmp(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_eq(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_eql(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_plus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_minus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_mul(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_div(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_idiv(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_modulo(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_divmod(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_pow(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_and(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_or(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_xor(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_lshift(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_big_rshift(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_integer_pack(
        val: VALUE,
        words: *mut ::std::os::raw::c_void,
        numwords: size_t,
        wordsize: size_t,
        nails: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_integer_unpack(
        words: *const ::std::os::raw::c_void,
        numwords: size_t,
        wordsize: size_t,
        nails: size_t,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_absint_size(val: VALUE, nlz_bits_ret: *mut ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn rb_absint_numwords(
        val: VALUE,
        word_numbits: size_t,
        nlz_bits_ret: *mut size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rb_absint_singlebit_p(val: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cmpint(val: VALUE, a: VALUE, b: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cmperr(a: VALUE, b: VALUE);
}
extern "C" {
    pub fn rb_complex_raw(real: VALUE, imag: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_new(real: VALUE, imag: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_new_polar(abs: VALUE, arg: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_polar(abs: VALUE, arg: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_real(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_imag(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_plus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_minus(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_mul(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_div(x: VALUE, y: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_uminus(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_conjugate(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_abs(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_arg(z: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_complex_pow(base: VALUE, exp: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_dbl_complex_new(real: f64, imag: f64) -> VALUE;
}
extern "C" {
    pub fn rb_Complex(real: VALUE, imag: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_new(func: rb_block_call_func_t, callback_obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_current() -> VALUE;
}
extern "C" {
    pub fn rb_fiber_alive_p(fiber: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_fiber(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_resume(fiber: VALUE, argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_resume_kw(
        fiber: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_yield(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_yield_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_transfer(
        fiber: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_transfer_kw(
        fiber: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_fiber_raise(fiber: VALUE, argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_dir_getwd() -> VALUE;
}
extern "C" {
    pub fn rb_enum_values_pack(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_exc_raise(exc: VALUE);
}
extern "C" {
    pub fn rb_exc_fatal(exc: VALUE);
}
extern "C" {
    pub fn rb_f_exit(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_f_abort(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_interrupt();
}
extern "C" {
    pub fn rb_frame_this_func() -> ID;
}
extern "C" {
    pub fn rb_jump_tag(state: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_obj_call_init(obj: VALUE, argc: ::std::os::raw::c_int, argv: *const VALUE);
}
extern "C" {
    pub fn rb_obj_call_init_kw(
        arg1: VALUE,
        arg2: ::std::os::raw::c_int,
        arg3: *const VALUE,
        arg4: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_frame_callee() -> ID;
}
extern "C" {
    pub fn rb_make_exception(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_set_end_proc(
        func: ::std::option::Option<unsafe extern "C" fn(arg: VALUE)>,
        arg: VALUE,
    );
}
pub type rb_enumerator_size_func =
    ::std::option::Option<unsafe extern "C" fn(recv: VALUE, argv: VALUE, eobj: VALUE) -> VALUE>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_arithmetic_sequence_components_t {
    pub begin: VALUE,
    pub end: VALUE,
    pub step: VALUE,
    pub exclude_end: ::std::os::raw::c_int,
}
extern "C" {
    pub fn rb_enumeratorize(
        recv: VALUE,
        meth: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enumeratorize_with_size(
        recv: VALUE,
        meth: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        func: rb_enumerator_size_func,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enumeratorize_with_size_kw(
        recv: VALUE,
        meth: VALUE,
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        func: rb_enumerator_size_func,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_arithmetic_sequence_extract(
        as_: VALUE,
        buf: *mut rb_arithmetic_sequence_components_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_arithmetic_sequence_beg_len_step(
        as_: VALUE,
        begp: *mut ::std::os::raw::c_long,
        lenp: *mut ::std::os::raw::c_long,
        stepp: *mut ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
        err: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_file_s_expand_path(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_expand_path(fname: VALUE, dname: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_s_absolute_path(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_absolute_path(fname: VALUE, dname: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_dirname(fname: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_find_file_ext(
        feature: *mut VALUE,
        exts: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_find_file(path: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_file_directory_p(__: VALUE, path: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_encode_ospath(path: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_is_absolute_path(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_file_size(file: VALUE) -> off_t;
}
extern "C" {
    pub fn rb_memerror();
}
extern "C" {
    pub fn rb_during_gc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_gc_mark_locations(start: *const VALUE, end: *const VALUE);
}
extern "C" {
    pub fn rb_mark_tbl(tbl: *mut st_table);
}
extern "C" {
    pub fn rb_mark_tbl_no_pin(tbl: *mut st_table);
}
extern "C" {
    pub fn rb_mark_set(tbl: *mut st_table);
}
extern "C" {
    pub fn rb_mark_hash(tbl: *mut st_table);
}
extern "C" {
    pub fn rb_gc_update_tbl_refs(ptr: *mut st_table);
}
extern "C" {
    pub fn rb_gc_mark_maybe(obj: VALUE);
}
extern "C" {
    pub fn rb_gc_mark(obj: VALUE);
}
extern "C" {
    pub fn rb_gc_mark_movable(obj: VALUE);
}
extern "C" {
    pub fn rb_gc_location(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gc_force_recycle(obj: VALUE);
}
extern "C" {
    pub fn rb_gc();
}
extern "C" {
    pub fn rb_gc_copy_finalizer(dst: VALUE, src: VALUE);
}
extern "C" {
    pub fn rb_gc_enable() -> VALUE;
}
extern "C" {
    pub fn rb_gc_disable() -> VALUE;
}
extern "C" {
    pub fn rb_gc_start() -> VALUE;
}
extern "C" {
    pub fn rb_define_finalizer(obj: VALUE, block: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_undefine_finalizer(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gc_count() -> size_t;
}
extern "C" {
    pub fn rb_gc_stat(key_or_buf: VALUE) -> size_t;
}
extern "C" {
    pub fn rb_gc_latest_gc_info(key_or_buf: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_gc_adjust_memory_usage(diff: ssize_t);
}
extern "C" {
    pub static mut rb_fs: VALUE;
}
extern "C" {
    pub static mut rb_output_fs: VALUE;
}
extern "C" {
    pub static mut rb_rs: VALUE;
}
extern "C" {
    pub static mut rb_default_rs: VALUE;
}
extern "C" {
    pub static mut rb_output_rs: VALUE;
}
extern "C" {
    pub fn rb_io_write(io: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_gets(io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_getbyte(io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_ungetc(io: VALUE, c: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_ungetbyte(io: VALUE, b: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_close(io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_flush(io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_eof(io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_binmode(io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_ascii8bit_binmode(io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_addstr(io: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_printf(argc: ::std::os::raw::c_int, argv: *const VALUE, io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_print(argc: ::std::os::raw::c_int, argv: *const VALUE, io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_puts(argc: ::std::os::raw::c_int, argv: *const VALUE, io: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_io_fdopen(
        fd: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_file_open(
        fname: *const ::std::os::raw::c_char,
        fmode: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_file_open_str(fname: VALUE, fmode: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_gets() -> VALUE;
}
extern "C" {
    pub fn rb_write_error(str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_write_error2(str_: *const ::std::os::raw::c_char, len: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_close_before_exec(
        lowfd: ::std::os::raw::c_int,
        maxhint: ::std::os::raw::c_int,
        noclose_fds: VALUE,
    );
}
extern "C" {
    pub fn rb_pipe(pipes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_reserved_fd_p(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_dup(oldfd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_dup2(
        oldfd: ::std::os::raw::c_int,
        newfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_pipe(fildes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_cloexec_fcntl_dupfd(
        fd: ::std::os::raw::c_int,
        minfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_update_max_fd(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_fd_fix_cloexec(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_load(path: VALUE, wrap: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_load_protect(
        path: VALUE,
        wrap: ::std::os::raw::c_int,
        state: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_provided(feature: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_feature_provided(
        feature: *const ::std::os::raw::c_char,
        loading: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_provide(feature: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_f_require(self_: VALUE, feature: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_require_string(feature: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ext_ractor_safe(flag: bool);
}
extern "C" {
    pub fn rb_marshal_dump(obj: VALUE, port: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_marshal_load(port: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_marshal_define_compat(
        newclass: VALUE,
        oldclass: VALUE,
        dumper: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
        loader: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE, arg2: VALUE) -> VALUE>,
    );
}
extern "C" {
    pub fn rb_num_zerodiv();
}
extern "C" {
    pub fn rb_num_coerce_bin(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num_coerce_cmp(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num_coerce_relop(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num_coerce_bit(lhs: VALUE, rhs: VALUE, op: ID) -> VALUE;
}
extern "C" {
    pub fn rb_num2fix(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_fix2str(val: VALUE, base: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_dbl_cmp(lhs: f64, rhs: f64) -> VALUE;
}
extern "C" {
    pub fn rb_int_positive_pow(x: ::std::os::raw::c_long, y: ::std::os::raw::c_ulong) -> VALUE;
}
extern "C" {
    pub fn rb_class_new_instance_pass_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        klass: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_new_instance(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        klass: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_class_new_instance_kw(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        klass: VALUE,
        kw_splat: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_eql(lhs: VALUE, rhs: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_any_to_s(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_inspect(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_instance_of(obj: VALUE, klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_is_kind_of(obj: VALUE, klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_alloc(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_clone(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_dup(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_init_copy(src: VALUE, dst: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_taint(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_tainted(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_untaint(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_untrust(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_untrusted(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_trust(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_freeze(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_frozen_p(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_id(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_memory_id(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_real(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_inherited_p(scion: VALUE, ascendant: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_superclass(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_convert_type(
        val: VALUE,
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        mid: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_check_convert_type(
        val: VALUE,
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        mid: *const ::std::os::raw::c_char,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_check_to_integer(val: VALUE, mid: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_check_to_float(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_to_int(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_to_int(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Integer(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_to_float(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Float(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_String(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Array(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Hash(val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_cstr_to_dbl(str_: *const ::std::os::raw::c_char, mode: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rb_str_to_dbl(str_: VALUE, mode: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rb_id_attrset(id: ID) -> ID;
}
extern "C" {
    pub fn rb_is_const_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_global_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_instance_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_attrset_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_class_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_local_id(id: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_is_junk_id(arg1: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_symname_p(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_backref_get() -> VALUE;
}
extern "C" {
    pub fn rb_backref_set(md: VALUE);
}
extern "C" {
    pub fn rb_lastline_get() -> VALUE;
}
extern "C" {
    pub fn rb_lastline_set(str_: VALUE);
}
extern "C" {
    pub fn rb_sym_all_symbols() -> VALUE;
}
extern "C" {
    pub fn rb_last_status_set(status: ::std::os::raw::c_int, pid: pid_t);
}
extern "C" {
    pub fn rb_last_status_get() -> VALUE;
}
extern "C" {
    pub fn rb_proc_exec(cmd: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_f_exec(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_waitpid(
        pid: pid_t,
        status: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn rb_syswait(pid: pid_t);
}
extern "C" {
    pub fn rb_spawn(argc: ::std::os::raw::c_int, argv: *const VALUE) -> pid_t;
}
extern "C" {
    pub fn rb_spawn_err(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        errbuf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> pid_t;
}
extern "C" {
    pub fn rb_proc_times(__: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_detach_process(pid: pid_t) -> VALUE;
}
extern "C" {
    pub fn rb_genrand_int32() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rb_genrand_real() -> f64;
}
extern "C" {
    pub fn rb_reset_random_seed();
}
extern "C" {
    pub fn rb_random_bytes(rnd: VALUE, n: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_random_int32(rnd: VALUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rb_random_real(rnd: VALUE) -> f64;
}
extern "C" {
    pub fn rb_random_ulong_limited(
        rnd: VALUE,
        limit: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_genrand_ulong_limited(i: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rb_range_new(beg: VALUE, end: VALUE, excl: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_range_beg_len(
        range: VALUE,
        begp: *mut ::std::os::raw::c_long,
        lenp: *mut ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
        err: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_range_values(
        range: VALUE,
        begp: *mut VALUE,
        endp: *mut VALUE,
        exclp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_rational_raw(num: VALUE, den: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_rational_new(num: VALUE, den: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_Rational(num: VALUE, den: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_rational_num(rat: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_rational_den(rat: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_flt_rationalize_with_prec(flt: VALUE, prec: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_flt_rationalize(flt: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_memcicmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_match_busy(md: VALUE);
}
extern "C" {
    pub fn rb_reg_nth_defined(n: ::std::os::raw::c_int, md: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_nth_match(n: ::std::os::raw::c_int, md: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_backref_number(match_: VALUE, backref: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_reg_last_match(md: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match_pre(md: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match_post(md: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match_last(md: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_new_str(src: VALUE, opts: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_reg_new(
        src: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        opts: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_reg_alloc() -> VALUE;
}
extern "C" {
    pub fn rb_reg_init_str(re: VALUE, s: VALUE, options: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match(re: VALUE, str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_match2(re: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_reg_options(re: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rb_argv0: VALUE;
}
extern "C" {
    pub fn rb_get_argv() -> VALUE;
}
extern "C" {
    pub fn rb_load_file(file: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_load_file_str(file: VALUE) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_fdset_t {
    pub maxfd: ::std::os::raw::c_int,
    pub fdset: *mut fd_set,
}
extern "C" {
    pub fn rb_fd_init(f: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_term(f: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_zero(f: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_set(fd: ::std::os::raw::c_int, f: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_clr(fd: ::std::os::raw::c_int, f: *mut rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_isset(fd: ::std::os::raw::c_int, f: *const rb_fdset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_fd_copy(dst: *mut rb_fdset_t, src: *const fd_set, max: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_fd_dup(dst: *mut rb_fdset_t, src: *const rb_fdset_t);
}
extern "C" {
    pub fn rb_fd_select(
        nfds: ::std::os::raw::c_int,
        rfds: *mut rb_fdset_t,
        wfds: *mut rb_fdset_t,
        efds: *mut rb_fdset_t,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_thread_fd_select(
        nfds: ::std::os::raw::c_int,
        rfds: *mut rb_fdset_t,
        wfds: *mut rb_fdset_t,
        efds: *mut rb_fdset_t,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_f_kill(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn ruby_posix_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn ruby_signal_name(signo: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ruby_default_signal(sig: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_f_sprintf(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_sprintf(fmt: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_vsprintf(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag) -> VALUE;
}
extern "C" {
    pub fn rb_str_catf(dst: VALUE, fmt: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_str_vcatf(
        dst: VALUE,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_format(argc: ::std::os::raw::c_int, argv: *const VALUE, fmt: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_new(ptr: *const ::std::os::raw::c_char, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_shared(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_frozen(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_with_class(
        obj: VALUE,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_tainted_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_tainted_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_external_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_external_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_locale_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_locale_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_filesystem_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_filesystem_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_new(capa: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_tmp_new(len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_usascii_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_usascii_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_utf8_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_utf8_str_new_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_usascii_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_utf8_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_to_interned_str(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_interned_str(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_interned_str_cstr(ptr: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_free(str_: VALUE);
}
extern "C" {
    pub fn rb_str_shared_replace(dst: VALUE, src: VALUE);
}
extern "C" {
    pub fn rb_str_buf_append(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_cat(
        arg1: VALUE,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_buf_cat_ascii(dst: VALUE, src: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_obj_as_string(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_check_string_type(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_must_asciicompat(obj: VALUE);
}
extern "C" {
    pub fn rb_str_dup(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_resurrect(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_locktmp(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_unlocktmp(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_dup_frozen(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_plus(lhs: VALUE, rhs: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_times(str_: VALUE, num: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_sublen(str_: VALUE, pos: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_str_substr(
        str_: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_subseq(
        str_: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_subpos(
        str_: VALUE,
        beg: ::std::os::raw::c_long,
        len: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_str_modify(str_: VALUE);
}
extern "C" {
    pub fn rb_str_modify_expand(str_: VALUE, capa: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_str_freeze(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_set_len(str_: VALUE, len: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rb_str_resize(str_: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_cat(
        dst: VALUE,
        src: *const ::std::os::raw::c_char,
        srclen: ::std::os::raw::c_long,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_cat_cstr(dst: VALUE, src: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_cat2(arg1: VALUE, arg2: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_append(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_concat(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_memhash(
        ptr: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_long,
    ) -> st_index_t;
}
extern "C" {
    pub fn rb_hash_start(i: st_index_t) -> st_index_t;
}
extern "C" {
    pub fn rb_str_hash(str_: VALUE) -> st_index_t;
}
extern "C" {
    pub fn rb_str_hash_cmp(str1: VALUE, str2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_comparable(str1: VALUE, str2: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_cmp(lhs: VALUE, rhs: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_equal(str1: VALUE, str2: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_drop_bytes(str_: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_update(
        dst: VALUE,
        beg: ::std::os::raw::c_long,
        len: ::std::os::raw::c_long,
        src: VALUE,
    );
}
extern "C" {
    pub fn rb_str_replace(dst: VALUE, src: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_inspect(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_dump(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_split(str_: VALUE, delim: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_str_setter(val: VALUE, id: ID, data: *mut VALUE);
}
extern "C" {
    pub fn rb_str_intern(str_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_sym_to_s(sym: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_strlen(str_: VALUE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_str_length(arg1: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_offset(str_: VALUE, pos: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_str_capacity(str_: VALUE) -> size_t;
}
extern "C" {
    pub fn rb_str_ellipsize(str_: VALUE, len: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_str_scrub(str_: VALUE, repl: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_str_succ(orig: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_new(klass: VALUE, ...) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define(name: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define_under(space: VALUE, name: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_struct_alloc(klass: VALUE, values: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_initialize(self_: VALUE, values: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_getmember(self_: VALUE, key: ID) -> VALUE;
}
extern "C" {
    pub fn rb_struct_s_members(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_members(self_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_alloc_noinit(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define_without_accessor(
        name: *const ::std::os::raw::c_char,
        super_: VALUE,
        func: rb_alloc_func_t,
        ...
    ) -> VALUE;
}
extern "C" {
    pub fn rb_struct_define_without_accessor_under(
        outer: VALUE,
        class_name: *const ::std::os::raw::c_char,
        super_: VALUE,
        alloc: rb_alloc_func_t,
        ...
    ) -> VALUE;
}
extern "C" {
    pub fn rb_thread_schedule();
}
extern "C" {
    pub fn rb_thread_wait_fd(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_thread_fd_writable(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_thread_fd_close(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_thread_alone() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_thread_sleep(sec: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_thread_sleep_forever();
}
extern "C" {
    pub fn rb_thread_sleep_deadly();
}
extern "C" {
    pub fn rb_thread_stop() -> VALUE;
}
extern "C" {
    pub fn rb_thread_wakeup(thread: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_wakeup_alive(thread: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_run(thread: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_kill(thread: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_create(
        f: ::std::option::Option<unsafe extern "C" fn(g: *mut ::std::os::raw::c_void) -> VALUE>,
        g: *mut ::std::os::raw::c_void,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_thread_wait_for(time: timeval);
}
extern "C" {
    pub fn rb_thread_current() -> VALUE;
}
extern "C" {
    pub fn rb_thread_main() -> VALUE;
}
extern "C" {
    pub fn rb_thread_local_aref(thread: VALUE, key: ID) -> VALUE;
}
extern "C" {
    pub fn rb_thread_local_aset(thread: VALUE, key: ID, val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_thread_atfork();
}
extern "C" {
    pub fn rb_thread_atfork_before_exec();
}
extern "C" {
    pub fn rb_exec_recursive(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        h: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exec_recursive_paired(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        p: VALUE,
        h: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exec_recursive_outer(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        h: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_exec_recursive_paired_outer(
        f: ::std::option::Option<
            unsafe extern "C" fn(g: VALUE, h: VALUE, r: ::std::os::raw::c_int) -> VALUE,
        >,
        g: VALUE,
        p: VALUE,
        h: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_thread_check_ints();
}
extern "C" {
    pub fn rb_thread_interrupted(thval: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_mutex_new() -> VALUE;
}
extern "C" {
    pub fn rb_mutex_locked_p(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_trylock(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_lock(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_unlock(mutex: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_sleep(self_: VALUE, timeout: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mutex_synchronize(
        mutex: VALUE,
        func: ::std::option::Option<unsafe extern "C" fn(arg: VALUE) -> VALUE>,
        arg: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_timespec_now(ts: *mut timespec);
}
extern "C" {
    pub fn rb_time_new(sec: time_t, usec: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_time_nano_new(sec: time_t, nsec: ::std::os::raw::c_long) -> VALUE;
}
extern "C" {
    pub fn rb_time_timespec_new(ts: *const timespec, offset: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_time_num_new(timev: VALUE, off: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_time_interval(num: VALUE) -> timeval;
}
extern "C" {
    pub fn rb_time_timeval(time: VALUE) -> timeval;
}
extern "C" {
    pub fn rb_time_timespec(time: VALUE) -> timespec;
}
extern "C" {
    pub fn rb_time_timespec_interval(num: VALUE) -> timespec;
}
extern "C" {
    pub fn rb_time_utc_offset(time: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_name(mod_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_path(mod_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_class_path_cached(mod_: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_set_class_path(klass: VALUE, space: VALUE, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rb_set_class_path_string(klass: VALUE, space: VALUE, name: VALUE);
}
extern "C" {
    pub fn rb_path_to_class(path: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_path2class(path: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_class_name(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_autoload_load(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_autoload_p(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_f_trace_var(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_f_untrace_var(argc: ::std::os::raw::c_int, argv: *const VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_f_global_variables() -> VALUE;
}
extern "C" {
    pub fn rb_alias_variable(dst: ID, src: ID);
}
extern "C" {
    pub fn rb_free_generic_ivar(obj: VALUE);
}
extern "C" {
    pub fn rb_ivar_get(obj: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_ivar_set(obj: VALUE, name: ID, val: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_ivar_defined(obj: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_ivar_foreach(
        obj: VALUE,
        func: ::std::option::Option<
            unsafe extern "C" fn(name: ID, val: VALUE, arg: st_data_t) -> ::std::os::raw::c_int,
        >,
        arg: st_data_t,
    );
}
extern "C" {
    pub fn rb_ivar_count(obj: VALUE) -> st_index_t;
}
extern "C" {
    pub fn rb_attr_get(obj: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_obj_instance_variables(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_obj_remove_instance_variable(obj: VALUE, name: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_const_at(
        arg1: VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_mod_const_of(
        arg1: VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rb_const_list(arg1: *mut ::std::os::raw::c_void) -> VALUE;
}
extern "C" {
    pub fn rb_mod_constants(argc: ::std::os::raw::c_int, argv: *const VALUE, recv: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_mod_remove_const(space: VALUE, name: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_const_defined(space: VALUE, name: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_const_defined_at(space: VALUE, name: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_const_defined_from(space: VALUE, name: ID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_const_get(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_const_get_at(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_const_get_from(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_const_set(space: VALUE, name: ID, val: VALUE);
}
extern "C" {
    pub fn rb_const_remove(space: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_cvar_defined(klass: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_cvar_set(klass: VALUE, name: ID, val: VALUE);
}
extern "C" {
    pub fn rb_cvar_get(klass: VALUE, name: ID) -> VALUE;
}
extern "C" {
    pub fn rb_cvar_find(klass: VALUE, name: ID, front: *mut VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_cv_set(klass: VALUE, name: *const ::std::os::raw::c_char, val: VALUE);
}
extern "C" {
    pub fn rb_cv_get(klass: VALUE, name: *const ::std::os::raw::c_char) -> VALUE;
}
extern "C" {
    pub fn rb_define_class_variable(arg1: VALUE, arg2: *const ::std::os::raw::c_char, arg3: VALUE);
}
extern "C" {
    pub fn rb_mod_class_variables(
        argc: ::std::os::raw::c_int,
        argv: *const VALUE,
        recv: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_mod_remove_cvar(mod_: VALUE, name: VALUE) -> VALUE;
}
extern "C" {
    pub fn ruby_native_thread_p() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_snprintf(
        str_: *mut ::std::os::raw::c_char,
        n: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruby_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        n: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
impl ruby_coderange_type {
    pub const RUBY_ENC_CODERANGE_MASK: ruby_coderange_type =
        ruby_coderange_type::RUBY_ENC_CODERANGE_BROKEN;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_coderange_type {
    RUBY_ENC_CODERANGE_UNKNOWN = 0,
    RUBY_ENC_CODERANGE_7BIT = 1048576,
    RUBY_ENC_CODERANGE_VALID = 2097152,
    RUBY_ENC_CODERANGE_BROKEN = 3145728,
}
pub type OnigUChar = ::std::os::raw::c_uchar;
pub type OnigCodePoint = ::std::os::raw::c_uint;
pub type OnigCtype = ::std::os::raw::c_uint;
pub type OnigDistance = size_t;
pub type OnigCaseFoldType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigCaseFoldCodeItem {
    pub byte_len: ::std::os::raw::c_int,
    pub code_len: ::std::os::raw::c_int,
    pub code: [OnigCodePoint; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigMetaCharTableType {
    pub esc: OnigCodePoint,
    pub anychar: OnigCodePoint,
    pub anytime: OnigCodePoint,
    pub zero_or_one_time: OnigCodePoint,
    pub one_or_more_time: OnigCodePoint,
    pub anychar_anytime: OnigCodePoint,
}
pub type OnigApplyAllCaseFoldFunc = ::std::option::Option<
    unsafe extern "C" fn(
        from: OnigCodePoint,
        to: *mut OnigCodePoint,
        to_len: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigEncodingTypeST {
    pub precise_mbc_enc_len: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            e: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub name: *const ::std::os::raw::c_char,
    pub max_enc_len: ::std::os::raw::c_int,
    pub min_enc_len: ::std::os::raw::c_int,
    pub is_mbc_newline: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub mbc_to_code: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> OnigCodePoint,
    >,
    pub code_to_mbclen: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub code_to_mbc: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            buf: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub mbc_case_fold: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            pp: *mut *const OnigUChar,
            end: *const OnigUChar,
            to: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub apply_all_case_fold: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            f: OnigApplyAllCaseFoldFunc,
            arg: *mut ::std::os::raw::c_void,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_case_fold_codes_by_str: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            p: *const OnigUChar,
            end: *const OnigUChar,
            acs: *mut OnigCaseFoldCodeItem,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub property_name_to_ctype: ::std::option::Option<
        unsafe extern "C" fn(
            enc: *const OnigEncodingTypeST,
            p: *const OnigUChar,
            end: *const OnigUChar,
        ) -> ::std::os::raw::c_int,
    >,
    pub is_code_ctype: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            ctype: OnigCtype,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_ctype_code_range: ::std::option::Option<
        unsafe extern "C" fn(
            ctype: OnigCtype,
            sb_out: *mut OnigCodePoint,
            ranges: *mut *const OnigCodePoint,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub left_adjust_char_head: ::std::option::Option<
        unsafe extern "C" fn(
            start: *const OnigUChar,
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> *mut OnigUChar,
    >,
    pub is_allowed_reverse_match: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub case_map: ::std::option::Option<
        unsafe extern "C" fn(
            flagP: *mut OnigCaseFoldType,
            pp: *mut *const OnigUChar,
            end: *const OnigUChar,
            to: *mut OnigUChar,
            to_end: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub ruby_encoding_index: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
}
pub type OnigEncodingType = OnigEncodingTypeST;
pub type OnigEncoding = *const OnigEncodingType;
pub type OnigOptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigSyntaxType {
    pub op: ::std::os::raw::c_uint,
    pub op2: ::std::os::raw::c_uint,
    pub behavior: ::std::os::raw::c_uint,
    pub options: OnigOptionType,
    pub meta_char_table: OnigMetaCharTableType,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigRepeatRange {
    pub lower: ::std::os::raw::c_int,
    pub upper: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_pattern_buffer {
    pub p: *mut ::std::os::raw::c_uchar,
    pub used: ::std::os::raw::c_uint,
    pub alloc: ::std::os::raw::c_uint,
    pub num_mem: ::std::os::raw::c_int,
    pub num_repeat: ::std::os::raw::c_int,
    pub num_null_check: ::std::os::raw::c_int,
    pub num_comb_exp_check: ::std::os::raw::c_int,
    pub num_call: ::std::os::raw::c_int,
    pub capture_history: ::std::os::raw::c_uint,
    pub bt_mem_start: ::std::os::raw::c_uint,
    pub bt_mem_end: ::std::os::raw::c_uint,
    pub stack_pop_level: ::std::os::raw::c_int,
    pub repeat_range_alloc: ::std::os::raw::c_int,
    pub options: OnigOptionType,
    pub repeat_range: *mut OnigRepeatRange,
    pub enc: OnigEncoding,
    pub syntax: *const OnigSyntaxType,
    pub name_table: *mut ::std::os::raw::c_void,
    pub case_fold_flag: OnigCaseFoldType,
    pub optimize: ::std::os::raw::c_int,
    pub threshold_len: ::std::os::raw::c_int,
    pub anchor: ::std::os::raw::c_int,
    pub anchor_dmin: OnigDistance,
    pub anchor_dmax: OnigDistance,
    pub sub_anchor: ::std::os::raw::c_int,
    pub exact: *mut ::std::os::raw::c_uchar,
    pub exact_end: *mut ::std::os::raw::c_uchar,
    pub map: [::std::os::raw::c_uchar; 256usize],
    pub int_map: *mut ::std::os::raw::c_int,
    pub int_map_backward: *mut ::std::os::raw::c_int,
    pub dmin: OnigDistance,
    pub dmax: OnigDistance,
    pub chain: *mut re_pattern_buffer,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_encoding_consts {
    RUBY_ENCODING_INLINE_MAX = 127,
    RUBY_ENCODING_SHIFT = 22,
    RUBY_ENCODING_MASK = 532676608,
    RUBY_ENCODING_MAXNAMELEN = 42,
}
pub type rb_encoding = OnigEncodingType;
extern "C" {
    pub fn rb_char_to_option_kcode(
        c: ::std::os::raw::c_int,
        option: *mut ::std::os::raw::c_int,
        kcode: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_replicate(
        name: *const ::std::os::raw::c_char,
        src: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_define_dummy_encoding(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_dummy_p(enc: *mut rb_encoding) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_to_index(enc: *mut rb_encoding) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_get_index(obj: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_set_index(obj: VALUE, encindex: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rb_enc_capable(obj: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_find_index(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_alias(
        alias: *const ::std::os::raw::c_char,
        orig: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_to_encoding_index(obj: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_to_encoding(obj: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_find_encoding(obj: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_get(obj: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_compatible(str1: VALUE, str2: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_check(str1: VALUE, str2: VALUE) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_associate_index(obj: VALUE, encindex: ::std::os::raw::c_int) -> VALUE;
}
extern "C" {
    pub fn rb_enc_associate(obj: VALUE, enc: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_enc_copy(dst: VALUE, src: VALUE);
}
extern "C" {
    pub fn rb_enc_from_index(idx: ::std::os::raw::c_int) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_find(name: *const ::std::os::raw::c_char) -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_enc_mbclen(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_fast_mbclen(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_precise_mbclen(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_ascget(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_codepoint_len(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_int,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rb_enc_codelen(
        code: ::std::os::raw::c_int,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_from_encoding(enc: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_enc_unicode_p(enc: *mut rb_encoding) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_ascii8bit_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_utf8_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_usascii_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_locale_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_filesystem_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_default_external_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_default_internal_encoding() -> *mut rb_encoding;
}
extern "C" {
    pub fn rb_ascii8bit_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_utf8_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_usascii_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_locale_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_filesystem_encindex() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_default_external() -> VALUE;
}
extern "C" {
    pub fn rb_enc_default_internal() -> VALUE;
}
extern "C" {
    pub fn rb_enc_set_default_external(encoding: VALUE);
}
extern "C" {
    pub fn rb_enc_set_default_internal(encoding: VALUE);
}
extern "C" {
    pub fn rb_locale_charmap(klass: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_enc_toupper(c: ::std::os::raw::c_int, enc: *mut rb_encoding)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_tolower(c: ::std::os::raw::c_int, enc: *mut rb_encoding)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_path_next(
        path: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_enc_path_skip_prefix(
        path: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_enc_path_last_separator(
        path: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_enc_path_end(
        path: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ruby_enc_find_basename(
        name: *const ::std::os::raw::c_char,
        baselen: *mut ::std::os::raw::c_long,
        alllen: *mut ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ruby_enc_find_extname(
        name: *const ::std::os::raw::c_char,
        len: *mut ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_enc_reg_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
        opts: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_sprintf(enc: *mut rb_encoding, fmt: *const ::std::os::raw::c_char, ...) -> VALUE;
}
extern "C" {
    pub fn rb_enc_vsprintf(
        enc: *mut rb_encoding,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_raise(enc: *mut rb_encoding, exc: VALUE, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rb_enc_str_new(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_str_new_cstr(ptr: *const ::std::os::raw::c_char, enc: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_enc_str_new_static(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_interned_str(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_interned_str_cstr(
        ptr: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_strlen(
        head: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_enc_nth(
        head: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
        nth: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_obj_encoding(obj: VALUE) -> VALUE;
}
extern "C" {
    pub fn rb_enc_str_buf_cat(
        str_: VALUE,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_uint_chr(code: ::std::os::raw::c_uint, enc: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_external_str_new_with_enc(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_str_export_to_enc(obj: VALUE, enc: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_str_conv_enc(str_: VALUE, from: *mut rb_encoding, to: *mut rb_encoding) -> VALUE;
}
extern "C" {
    pub fn rb_str_conv_enc_opts(
        str_: VALUE,
        from: *mut rb_encoding,
        to: *mut rb_encoding,
        ecflags: ::std::os::raw::c_int,
        ecopts: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_enc_str_coderange(str_: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_str_coderange_scan_restartable(
        str_: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
        cr: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_enc_str_asciionly_p(str_: VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_memsearch(
        x: *const ::std::os::raw::c_void,
        m: ::std::os::raw::c_long,
        y: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rb_intern3(
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> ID;
}
extern "C" {
    pub fn rb_enc_symname_p(
        str_: *const ::std::os::raw::c_char,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_enc_symname2_p(
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_check_id_cstr(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> ID;
}
extern "C" {
    pub fn rb_check_symbol_cstr(
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_long,
        enc: *mut rb_encoding,
    ) -> VALUE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rb_econv_result_t {
    econv_invalid_byte_sequence = 0,
    econv_undefined_conversion = 1,
    econv_destination_buffer_full = 2,
    econv_source_buffer_empty = 3,
    econv_finished = 4,
    econv_after_output = 5,
    econv_incomplete_input = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_econv_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rb_str_encode(
        str_: VALUE,
        to: VALUE,
        ecflags: ::std::os::raw::c_int,
        ecopts: VALUE,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_has_convpath_p(
        from_encoding: *const ::std::os::raw::c_char,
        to_encoding: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_prepare_options(
        opthash: VALUE,
        ecopts: *mut VALUE,
        ecflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_prepare_opts(opthash: VALUE, ecopts: *mut VALUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_open(
        source_encoding: *const ::std::os::raw::c_char,
        destination_encoding: *const ::std::os::raw::c_char,
        ecflags: ::std::os::raw::c_int,
    ) -> *mut rb_econv_t;
}
extern "C" {
    pub fn rb_econv_open_opts(
        source_encoding: *const ::std::os::raw::c_char,
        destination_encoding: *const ::std::os::raw::c_char,
        ecflags: ::std::os::raw::c_int,
        ecopts: VALUE,
    ) -> *mut rb_econv_t;
}
extern "C" {
    pub fn rb_econv_convert(
        ec: *mut rb_econv_t,
        source_buffer_ptr: *mut *const ::std::os::raw::c_uchar,
        source_buffer_end: *const ::std::os::raw::c_uchar,
        destination_buffer_ptr: *mut *mut ::std::os::raw::c_uchar,
        destination_buffer_end: *mut ::std::os::raw::c_uchar,
        flags: ::std::os::raw::c_int,
    ) -> rb_econv_result_t;
}
extern "C" {
    pub fn rb_econv_close(ec: *mut rb_econv_t);
}
extern "C" {
    pub fn rb_econv_set_replacement(
        ec: *mut rb_econv_t,
        str_: *const ::std::os::raw::c_uchar,
        len: size_t,
        encname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_decorate_at_first(
        ec: *mut rb_econv_t,
        decorator_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_decorate_at_last(
        ec: *mut rb_econv_t,
        decorator_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_open_exc(
        senc: *const ::std::os::raw::c_char,
        denc: *const ::std::os::raw::c_char,
        ecflags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_insert_output(
        ec: *mut rb_econv_t,
        str_: *const ::std::os::raw::c_uchar,
        len: size_t,
        str_encoding: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_encoding_to_insert_output(ec: *mut rb_econv_t)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_econv_check_error(ec: *mut rb_econv_t);
}
extern "C" {
    pub fn rb_econv_make_exception(ec: *mut rb_econv_t) -> VALUE;
}
extern "C" {
    pub fn rb_econv_putbackable(ec: *mut rb_econv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_econv_putback(
        ec: *mut rb_econv_t,
        p: *mut ::std::os::raw::c_uchar,
        n: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rb_econv_asciicompat_encoding(
        encname: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rb_econv_str_convert(
        ec: *mut rb_econv_t,
        src: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_substr_convert(
        ec: *mut rb_econv_t,
        src: VALUE,
        byteoff: ::std::os::raw::c_long,
        bytesize: ::std::os::raw::c_long,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_str_append(
        ec: *mut rb_econv_t,
        src: VALUE,
        dst: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_substr_append(
        ec: *mut rb_econv_t,
        src: VALUE,
        byteoff: ::std::os::raw::c_long,
        bytesize: ::std::os::raw::c_long,
        dst: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_append(
        ec: *mut rb_econv_t,
        bytesrc: *const ::std::os::raw::c_char,
        bytesize: ::std::os::raw::c_long,
        dst: VALUE,
        flags: ::std::os::raw::c_int,
    ) -> VALUE;
}
extern "C" {
    pub fn rb_econv_binmode(ec: *mut rb_econv_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ruby_econv_flag_type {
    RUBY_ECONV_ERROR_HANDLER_MASK = 255,
    RUBY_ECONV_INVALID_MASK = 15,
    RUBY_ECONV_INVALID_REPLACE = 2,
    RUBY_ECONV_UNDEF_MASK = 240,
    RUBY_ECONV_UNDEF_REPLACE = 32,
    RUBY_ECONV_UNDEF_HEX_CHARREF = 48,
    RUBY_ECONV_DECORATOR_MASK = 65280,
    RUBY_ECONV_NEWLINE_DECORATOR_MASK = 16128,
    RUBY_ECONV_NEWLINE_DECORATOR_READ_MASK = 3840,
    RUBY_ECONV_NEWLINE_DECORATOR_WRITE_MASK = 12288,
    RUBY_ECONV_UNIVERSAL_NEWLINE_DECORATOR = 256,
    RUBY_ECONV_CRLF_NEWLINE_DECORATOR = 4096,
    RUBY_ECONV_CR_NEWLINE_DECORATOR = 8192,
    RUBY_ECONV_XML_TEXT_DECORATOR = 16384,
    RUBY_ECONV_XML_ATTR_CONTENT_DECORATOR = 32768,
    RUBY_ECONV_STATEFUL_DECORATOR_MASK = 15728640,
    RUBY_ECONV_XML_ATTR_QUOTE_DECORATOR = 1048576,
    RUBY_ECONV_DEFAULT_NEWLINE_DECORATOR = 0,
    RUBY_ECONV_PARTIAL_INPUT = 65536,
    RUBY_ECONV_AFTER_OUTPUT = 131072,
    RUBY_ECONV_FLAGS_PLACEHOLDER = 131073,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
